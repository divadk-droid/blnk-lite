/**
 * Extended Vulnerability Detection Pattern Database
 * Smart Contract Auditor-style comprehensive pattern matching
 */

class VulnerabilityPatternDB {
  constructor() {
    this.patterns = this.initializePatterns();
    this.knownExploits = this.initializeKnownExploits();
    this.severityWeights = {
      CRITICAL: 100,
      HIGH: 70,
      MEDIUM: 40,
      LOW: 10,
      INFO: 0
    };
  }

  /**
   * Initialize vulnerability patterns
   */
  initializePatterns() {
    return {
      // Reentrancy patterns
      reentrancy: {
        name: 'Reentrancy Attack',
        severity: 'CRITICAL',
        patterns: [
          {
            id: 'REENT-001',
            name: 'External Call Before State Update',
            regex: /(\.call{value:|\.transfer\(|\.send\()[^;]+;[^}]*[a-zA-Z_][a-zA-Z0-9_]*\s*=|balance\[|balances\[/s,
            description: 'External call made before state variables are updated',
            recommendation: 'Use Checks-Effects-Interactions pattern'
          },
          {
            id: 'REENT-002',
            name: 'No ReentrancyGuard',
            regex: /function\s+\w+\s*\([^)]*\)\s*(?:public|external)[^{]*{(?![^}]*nonReentrant)/s,
            description: 'Function making external calls without reentrancy protection',
            recommendation: 'Add nonReentrant modifier from OpenZeppelin'
          }
        ]
      },

      // Access control patterns
      accessControl: {
        name: 'Access Control Issues',
        severity: 'CRITICAL',
        patterns: [
          {
            id: 'ACCESS-001',
            name: 'Missing Access Control',
            regex: /function\s+(?:mint|burn|transferOwnership|pause|unpause)\s*\([^)]*\)\s*public(?![^}]*onlyOwner|require\s*\(\s*msg\.sender)/s,
            description: 'Critical function lacks access control',
            recommendation: 'Add onlyOwner or custom access control'
          },
          {
            id: 'ACCESS-002',
            name: 'tx.origin Authentication',
            regex: /tx\.origin\s*==/,
            description: 'Using tx.origin for authentication is vulnerable',
            recommendation: 'Use msg.sender instead'
          },
          {
            id: 'ACCESS-003',
            name: 'Signature Replay',
            regex: /ecrecover.*nonce.*(?!mapping)/s,
            description: 'Potential signature replay vulnerability',
            recommendation: 'Implement nonce tracking with mapping'
          }
        ]
      },

      // Arithmetic patterns
      arithmetic: {
        name: 'Arithmetic Issues',
        severity: 'HIGH',
        patterns: [
          {
            id: 'ARITH-001',
            name: 'Integer Overflow (Pre-0.8)',
            regex: /pragma\s+solidity\s+\^?0\.[0-5]\./,
            description: 'Solidity version without built-in overflow protection',
            recommendation: 'Use Solidity 0.8+ or SafeMath'
          },
          {
            id: 'ARITH-002',
            name: 'Unchecked External Call',
            regex: /\.call{value:[^}]*}\s*\([^)]*\)(?!\s*;\s*require)/s,
            description: 'External call return value not checked',
            recommendation: 'Check return value or use transfer()'
          },
          {
            id: 'ARITH-003',
            name: 'Division Before Multiplication',
            regex: /\/\s*\d+.*\*/s,
            description: 'Potential precision loss in calculation',
            recommendation: 'Multiply before dividing'
          }
        ]
      },

      // Oracle manipulation
      oracle: {
        name: 'Oracle Manipulation',
        severity: 'HIGH',
        patterns: [
          {
            id: 'ORACLE-001',
            name: 'Single Price Feed',
            regex: /getPrice\s*\(\s*\)\s*(?:external|public)[^{]*{[^}]*return/s,
            description: 'Using single price source without validation',
            recommendation: 'Use multiple oracle sources with TWAP'
          },
          {
            id: 'ORACLE-002',
            name: 'No Price Staleness Check',
            regex: /latestRoundData\(\)|getLatestPrice\(\)(?!.*require.*\>.*timestamp)/s,
            description: 'Price data may be stale',
            recommendation: 'Add timestamp validation'
          }
        ]
      },

      // Front-running patterns
      frontRunning: {
        name: 'Front-running Vulnerabilities',
        severity: 'MEDIUM',
        patterns: [
          {
            id: 'FRONT-001',
            name: 'Uncapped Slippage',
            regex: /amountOutMin\s*:\s*0\s*}/,
            description: 'No slippage protection on swap',
            recommendation: 'Set reasonable amountOutMin'
          },
          {
            id: 'FRONT-002',
            name: 'Public Mempool Transaction',
            regex: /function\s+\w+.*(?:swap|trade|exchange).*(?:public|external)(?!.*onlyOwner)/s,
            description: 'Trade function visible to mempool snipers',
            recommendation: 'Use private mempool or commit-reveal'
          }
        ]
      },

      // Gas optimization issues
      gas: {
        name: 'Gas Issues',
        severity: 'LOW',
        patterns: [
          {
            id: 'GAS-001',
            name: 'Storage in Loop',
            regex: /for\s*\([^)]*\)\s*\{[^}]*storage\s+/s,
            description: 'Storage variable accessed in loop',
            recommendation: 'Cache storage variable in memory'
          },
          {
            id: 'GAS-002',
            name: 'Unbounded Loop',
            regex: /for\s*\(\s*uint\s+\w+\s*=\s*0\s*;\s*\w+\s*<\s*(?!\d|\.length)/s,
            description: 'Loop may run out of gas',
            recommendation: 'Add upper bound or pagination'
          }
        ]
      },

      // Token-specific patterns
      token: {
        name: 'Token Standard Issues',
        severity: 'MEDIUM',
        patterns: [
          {
            id: 'TOKEN-001',
            name: 'ERC20 Approval Race',
            regex: /approve\s*\([^,]+,\s*[^)]+\)(?!.*approve\s*\([^,]+,\s*0\s*\))/s,
            description: 'ERC20 approve race condition possible',
            recommendation: 'Set approval to 0 before changing'
          },
          {
            id: 'TOKEN-002',
            name: 'Missing Zero Address Check',
            regex: /function\s+(?:mint|transfer|burn)[^{]*{[^}]*(?!>0x0|zero|address\(0\))/s,
            description: 'No validation against zero address',
            recommendation: 'Add zero address checks'
          },
          {
            id: 'TOKEN-003',
            name: 'Fee-on-Transfer Not Handled',
            regex: /transferFrom\s*\([^)]+\)\s*;\s*(?!.*balance)/s,
            description: 'May not handle fee-on-transfer tokens',
            recommendation: 'Check balance before/after transfer'
          }
        ]
      },

      // Upgradeability patterns
      upgradeability: {
        name: 'Upgradeability Issues',
        severity: 'MEDIUM',
        patterns: [
          {
            id: 'UPGRADE-001',
            name: 'Uninitialized Implementation',
            regex: /contract\s+\w+\s+is\s+(?:Initializable|UUPSUpgradeable)(?!.*function\s+initialize)/s,
            description: 'Upgradeable contract may lack initializer',
            recommendation: 'Add initialize function with initializer modifier'
          },
          {
            id: 'UPGRADE-002',
            name: 'Self-Destruct in Upgradeable',
            regex: /selfdestruct|suicide/,
            description: 'Self-destruct can brick upgradeable contract',
            recommendation: 'Remove self-destruct or add safeguards'
          }
        ]
      },

      // Timestamp dependence
      timestamp: {
        name: 'Timestamp Dependence',
        severity: 'LOW',
        patterns: [
          {
            id: 'TIME-001',
            name: 'Strict Equality on block.timestamp',
            regex: /block\.timestamp\s*==/,
            description: 'Miner can manipulate exact timestamp',
            recommendation: 'Use > or < comparisons'
          }
        ]
      },

      // Delegate call
      delegatecall: {
        name: 'Delegate Call Issues',
        severity: 'CRITICAL',
        patterns: [
          {
            id: 'DELEGATE-001',
            name: 'Unsafe Delegate Call',
            regex: /\.delegatecall\s*\([^)]*\)(?!\s*;\s*require)/s,
            description: 'Delegate call to untrusted contract',
            recommendation: 'Validate target address or avoid delegatecall'
          }
        ]
      }
    };
  }

  /**
   * Initialize known exploit database
   */
  initializeKnownExploits() {
    return [
      {
        name: 'The DAO Hack',
        type: 'Reentrancy',
        date: '2016-06-17',
        loss: '$60M',
        pattern: 'REENT-001'
      },
      {
        name: 'Parity Multisig',
        type: 'Access Control',
        date: '2017-11-06',
        loss: '$280M',
        pattern: 'ACCESS-001'
      },
      {
        name: 'Compound Oracle',
        type: 'Oracle Manipulation',
        date: '2021-11-30',
        loss: '$100M',
        pattern: 'ORACLE-001'
      },
      {
        name: 'Poly Network',
        type: 'Access Control',
        date: '2021-08-10',
        loss: '$610M',
        pattern: 'ACCESS-002'
      }
    ];
  }

  /**
   * Scan bytecode for vulnerabilities
   */
  async scanForVulnerabilities(bytecode, sourceCode = null) {
    const findings = [];
    let totalScore = 0;

    // Scan each pattern category
    for (const [category, data] of Object.entries(this.patterns)) {
      for (const pattern of data.patterns) {
        const matches = this.findMatches(bytecode, sourceCode, pattern);
        
        if (matches.found) {
          const finding = {
            id: pattern.id,
            category: data.name,
            severity: data.severity,
            name: pattern.name,
            description: pattern.description,
            recommendation: pattern.recommendation,
            matches: matches.locations,
            confidence: matches.confidence,
            score: this.severityWeights[data.severity]
          };

          findings.push(finding);
          totalScore += finding.score;
        }
      }
    }

    // Sort by severity
    findings.sort((a, b) => this.severityWeights[b.severity] - this.severityWeights[a.severity]);

    return {
      risk_score: Math.min(totalScore, 100),
      findings_count: findings.length,
      critical_count: findings.filter(f => f.severity === 'CRITICAL').length,
      high_count: findings.filter(f => f.severity === 'HIGH').length,
      medium_count: findings.filter(f => f.severity === 'MEDIUM').length,
      low_count: findings.filter(f => f.severity === 'LOW').length,
      findings,
      summary: this.generateSummary(findings),
      similar_exploits: this.findSimilarExploits(findings)
    };
  }

  /**
   * Find pattern matches in code
   */
  findMatches(bytecode, sourceCode, pattern) {
    const codeToSearch = sourceCode || bytecode;
    const matches = [];
    let confidence = 'high';

    if (pattern.regex.test(codeToSearch)) {
      // Find all match locations
      const regex = new RegExp(pattern.regex.source, 'g');
      let match;
      while ((match = regex.exec(codeToSearch)) !== null) {
        matches.push({
          index: match.index,
          length: match[0].length,
          snippet: codeToSearch.substring(Math.max(0, match.index - 50), match.index + match[0].length + 50)
        });
      }

      // Adjust confidence based on context
      if (!sourceCode && bytecode) {
        confidence = 'medium'; // Bytecode analysis is less precise
      }
    }

    return {
      found: matches.length > 0,
      locations: matches,
      confidence
    };
  }

  /**
   * Generate scan summary
   */
  generateSummary(findings) {
    if (findings.length === 0) {
      return {
        status: 'SAFE',
        message: 'No vulnerabilities detected',
        action: 'PASS'
      };
    }

    const critical = findings.filter(f => f.severity === 'CRITICAL');
    const high = findings.filter(f => f.severity === 'HIGH');

    if (critical.length > 0) {
      return {
        status: 'CRITICAL',
        message: `${critical.length} critical vulnerabilities found`,
        action: 'BLOCK',
        immediate_action: 'Do not deploy. Fix critical issues first.'
      };
    }

    if (high.length > 0) {
      return {
        status: 'HIGH_RISK',
        message: `${high.length} high-risk vulnerabilities found`,
        action: 'REVIEW',
        immediate_action: 'Manual review required before deployment.'
      };
    }

    return {
      status: 'MEDIUM_RISK',
      message: `${findings.length} medium/low risk issues found`,
      action: 'MONITOR',
      immediate_action: 'Review and fix when possible.'
    };
  }

  /**
   * Find similar historical exploits
   */
  findSimilarExploits(findings) {
    const exploitPatterns = findings.map(f => f.id);
    return this.knownExploits.filter(exploit => 
      exploitPatterns.includes(exploit.pattern)
    );
  }

  /**
   * Get remediation guide
   */
  getRemediationGuide(findingId) {
    const guides = {
      'REENT-001': `
        1. Update state variables BEFORE external calls
        2. Use Checks-Effects-Interactions pattern
        3. Add ReentrancyGuard from OpenZeppelin
        Example:
        
        // BAD
        (bool success, ) = recipient.call{value: amount}("");
        balances[msg.sender] -= amount;
        
        // GOOD
        balances[msg.sender] -= amount;
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");
      `,
      'ACCESS-001': `
        1. Add access control modifiers
        2. Use OpenZeppelin's Ownable or AccessControl
        3. Validate caller permissions
        
        Example:
        function mint(address to, uint256 amount) public onlyOwner {
            _mint(to, amount);
        }
      `,
      'ORACLE-001': `
        1. Use multiple price sources
        2. Implement TWAP (Time-Weighted Average Price)
        3. Add price deviation checks
        
        Example:
        require(
            price >= lastPrice * 90 / 100 && 
            price <= lastPrice * 110 / 100,
            "Price deviation too high"
        );
      `
    };

    return guides[findingId] || 'See general security best practices.';
  }
}

module.exports = { VulnerabilityPatternDB };
